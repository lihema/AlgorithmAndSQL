#设计模式

##设计模式概览

###1.面向对象与设计模式需要掌握的特性
````
·面向对象的四大特性：封装、抽象、继承、多态
·面向对象编程与面向过程的区别与联系
·面向对象分析、面向对象设计、面向对象编程
·接口和抽象类的区别以及各自的应用场景
·基于接口而非实现编程的设计思想
·多用组合少用继承的设计思想
·面向过程的贫血模型和面向对象的充血模型
````
###2.设计原则
````
SOLID原则
·SRP 单一职责
·OCP 开闭原则
·LSP 里式替换原则
·ISP 接口隔离原则
·DIP 依赖倒置原则

·DRY原则
·KISS原则
·YAGNI原则
·LOD法则
````
###3.设计模式
````
1.创建型
常用：
单例模式、工厂模式、建造者模式

不常用：
原型模式

2.结构型
常用：
代理模式、桥接模式、装饰着模式、适配器模式

不常用：
门面模式、组合模式、享元模式


3.行为型
常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式

不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式

````
###4.编程规范
````
baba规范
````
###5.代码重构
````
注重 重构的目的（why）、对象（what）、时机（when）、方法（how）;
保证重构不出错的技术手段：单元测试和代码的可测试性；
两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）
````
###6.联系

##面向对象
###什么是面向对象
````
只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了
````
###面向对象分析和面向对象设计
````
面向对象分析就是要搞清楚做什么
面向对象设计就是要搞清楚怎么做
面向对象编程就是将分析和设计的的结果翻译成代码的过程
与DDD结合
````
##四大特性解决什么问题
###封装
````
封装的意义在于控制访问权限，不设置set方法，保证有些值在构造方法初始化完成后就不能再传值
隐藏信息、保护数据
````
###抽象
````
1.简化复杂系统，只关注方法本身，不去考虑实现
2.开闭原则、代码解耦（基于接口）
3.加一层包装
````
###继承
````
1.主要解决代码复用
2.表示类之间的 is-a 关系
````
###多态
````
继承加方法重写
接口类语法
多态特性能提高代码的可扩展性和复用性：用父类或者接口的方法重写或实现将一个方法有不同实现

````
###接口和抽象类有哪些区别
````
抽象类：
1.不能被实例化
2.可以包含属性和方法
3.子类继承抽象类必须实现抽象类中的所有抽象方法

解决问题：
1.代码复用问题
2.将关键方法写成抽象方法，保证核心方法需要被实现，实现多态

接口：
1.不能包含属性
2.接口只能声明方法，方法不能包含代码实现
3.必须实现接口中的全部方法

解决问题：
1.用于解耦，提升扩展性

接口还是抽象类
is-a代码复用抽象
has-a解决抽象问题
抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。
我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。
````
###接口的意义
````
接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。

上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。

越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，
而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。

何时定义为接口：
1.实现类必须有扩展的需求
2.从整体系统上看系统不太稳定，需要不断升级

解决接口实现问题使用多态可以使用 配置文件+反射+工厂模式


1、简单工厂方法
ImageStore imageStore = ImageStoreFactory.newInstance(SOTRE_TYPE_CONFIG);
config文件可以写类似properties的文件，使用key-value存储。

缺点：再新增另一种存储手段时，需要修改工厂类和添加新的类。修改工厂类，违反了开放-封闭原则。

那有没有更好一点的方法呢？

2、使用反射。
在配置文件中定义需要的image store类型。
在ProcessJob中
ImageStore store = (ImageStore) Class.forName(STORE_CLASS)
    .newInstance();

缺点：使用反射，在大量创建对象时会有性能损失。

````
### 多用组合少用继承
````
组合：用接口实现，一个接口放一个功能，一个对象可以实现多个接口达到组合的效果，但是会造成类太多结构复杂

public interface Flyable {
  void fly();
}
public interface Tweetable {
  void tweet();
}
public interface EggLayable {
  void layEgg();
}
public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  //... 省略其他属性和方法...
  @Override
  public void tweet() { //... }
  @Override
  public void layEgg() { //... }
}
public class Sparrow impelents Flayable, Tweetable, EggLayable {//麻雀
  //... 省略其他属性和方法...
  @Override
  public void fly() { //... }
  @Override
  public void tweet() { //... }
  @Override
  public void layEgg() { //... }
}

继承：类之间继承结构稳定，继承层比较浅继承关系不复杂可以用继承，继承的层次比较深少用继承，
基本最佳使用：利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。
子类复用父类中的属性和方法，达到代码复用的目的。
有时需要保证保证函数的改变函数的逻辑，但是权限不允许时，可以使用继承重写该方法


//经典设计模式的类图
````
### 面向对象实践
````

````
## 设计原则
### 单一职责原则（SRP）
````
一个类或者模块只负责完成一个职责（SRP），一个类只包含单一的业务功能
一些特定的用户属性只“使用”在一个业务功能中，若有多个业务使用该对象可以将其抽出独立成新的
类，如若想完成单点登录的功能需要将与身份验证相关的内容从中剔除出去形成一个独立的类，一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。

针对单一职责判断的方法：

1.类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；
2.类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；
3.私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
4.比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
5.类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。

一个类最好不要超过200行，函数个数和属性个数最好不要超过10个

对于两个类有关联的情景最好不要拆分



````

### 开闭原则
````
1.核心原则：对扩展开放、对修改关闭，识别近期扩展点

关键点：1.增加字段方法等不会影响原来代码的改动
       2.让核心功能开闭，将多次使用的属性组成对象
       
 例子：
 抽象顶层对象Abstract存放 handler抽象业务流程集合 增加业务集合方法 执行核心业务集合方法
 拥有多属性的入参对象
 抽象业务handler
 多个继承抽象handler的具体handler
 
 核心思想：
 扩展意识、抽象意识、封装意识
 在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、
 如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、
 做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”（abstract）
 
 还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，
 给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，
 替换掉老的实现即可，上游系统的代码几乎不需要修改。（private）
 
 方法论：
 多态、依赖注入、基于接口而非实现，多种设计模式
 
 流程：
 1.确定需要抽象的对象
 2.确定封装的对象
 3.扩展点
````
### 里式替换
````
子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性,子类只是父类的具体实现
修改子类代码不会对父类的处理逻辑有影响，核心：按照协议来设计

常常违背LSP的代码：
1.子类违背父类声明要实现的功能
2.子类违背父类对输入、输出、异常的约定
3.子类违背父类注释中所罗列的任何特殊说明
````
````
接口隔离
在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，
那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。

着重关注接口

````
````
控制反转、依赖反转、依赖注入，这三者有何区别和联系？
控制反转
这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。
在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。
核心：使用一个抽象类或者接口来控制程序关键，如用boolean型返回值的方法的执行流程   关注的是流程的变换

依赖注入
使用构造器将需要的类对象注入进来，灵活的控制需要依赖的类

依赖反转原则（DIP）
高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。
除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。

总结：构造器里传接口

````

````
责任链：
在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。
一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，
以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。

实现方式：
1.Handler作为所有处理器类的抽象父类
````


